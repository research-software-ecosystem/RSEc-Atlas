{"tool_name":"cuttlefish","contents":["biotools","bioschemas","bioconda"],"fetched_metadata":{"bioconda":{"name":"cuttlefish","version":"2.2.0","home":"https://github.com/COMBINE-lab/cuttlefish","documentation":"https://github.com/COMBINE-lab/cuttlefish/blob/v2.2.0/README.md","license":"BSD-3-Clause","summary":"Construction of the compacted de Bruijn graph efficiently.","identifiers":["doi:10.1093/bioinformatics/btab309","doi:10.1186/s13059-022-02743-6","biotools:cuttlefish"]},"biotools":{"id":"cuttlefish","home":"https://github.com/COMBINE-lab/Cuttlefish","license":"BSD-3-Clause","summary":"Cuttlefish is a fast, parallel, and very lightweight memory tool to construct the compacted de Bruijn graph from genome reference(s). Cuttlefish is a tool for constructing the (colored) compacted de Bruijn graph from a collection of one or more genome references. Cuttlefish introduces a novel modeling scheme of the de Bruijn graph vertices as finite-state automata, and constrains the state-space for the automata to enable tracking of their transitioning states with very low memory usage. Cuttlefish is also fast and highly parallelizable. Experimental results demonstrate that the algorithm scales much better than existing approaches, especially as the number and scale of the input references grow.","addition_date":"2021-01-18T11:38:26Z","last_update_date":"2021-02-18T18:42:33Z","tool_type":["Command-line tool"]},"bioschemas":{"name":"Cuttlefish","home":"https://bio.tools/cuttlefish","license":"BSD-3-Clause","summary":"Cuttlefish is a fast, parallel, and very lightweight memory tool to construct the compacted de Bruijn graph from genome reference(s). Cuttlefish is a tool for constructing the (colored) compacted de Bruijn graph from a collection of one or more genome references. Cuttlefish introduces a novel modeling scheme of the de Bruijn graph vertices as finite-state automata, and constrains the state-space for the automata to enable tracking of their transitioning states with very low memory usage. Cuttlefish is also fast and highly parallelizable. Experimental results demonstrate that the algorithm scales much better than existing approaches, especially as the number and scale of the input references grow.","tool_type":"sc:SoftwareApplication"}}}